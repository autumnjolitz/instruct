{% macro getter_func_template(field_name, get_variable_template) %}
def make_getter(type_def):
    '''
    Factory function that allows the metaclass to pass
    data into this context (like type definitions).
    '''
    def _get_{{field_name}}(self) -> type_def:
        '''
        Autogenerated code: Setter function for {{field_name}}.
        '''
        return self._data.{{field_name}}
    return _get_{{field_name}}

def make_raw_getter():
    def _get_{{field_name}}(self):
        return self._data.{{field_name}}
    return _get_{{field_name}}

{% endmacro %}

{% macro setter_func_template(field_name, setter_variable_template, on_sets=None, has_coercion=False, type_failure_func_names=None, history=False) %}
def make_raw_setter():
    def _set_{{field_name}}(self, val):
        self._data.{{field_name}} = val
    return _set_{{field_name}}


def make_setter(type_def, fast, derived, type_restriction, coerce_types=(), coerce_func=None):
    if isinstance(type_restriction, type):
        type_restriction = (type_restriction,)

    assert isinstance(type_restriction, tuple) and all(
        isinstance(cls, type) for cls in type_restriction), \
        'Not all types {!r} are cls'.format(type_restriction)

    if fast:
        def _set_{{field_name}}(self, val: type_def) -> NoneType:
            {%- if has_coercion %}
            if isinstance(val, coerce_types):
                val = coerce_func(val)
            {%- endif %}
            if not isinstance(val, type_restriction):
                raise TypeError("{}".format(type(val).__name__))

            _old_value = self._data.{{field_name}}
            self._data.{{field_name}} = val
            {%- if on_sets %}
            {%- for on_func_name in on_sets %}
            self.{{on_func_name}}(_old_value, val)
            {%- endfor %}
            {%- endif %}
            {%- if history %}
            if not self._flags:
                return
            self._record_change('{{field_name}}', _old_value, val)
            {%- endif %}
            del _old_value
    else:
        def _set_{{field_name}}(self, val: type_def) -> NoneType:
            _old_value = self._data.{{field_name}}
            if not isinstance(val, type_restriction):
                if isinstance(val, dict) and derived is not None:
                    val = derived(**val)
                {%- if has_coercion %}
                if isinstance(val, coerce_types):
                    val = coerce_func(val)
                {%- endif %}
                if not isinstance(val, type_restriction):
                    {%- if type_failure_func_names %}
                    handled_error = (func(val) for func in (
                        {%- for on_error_func_name in type_failure_func_names %}
                        self.{{on_error_func_name}},
                        {%- endfor %}
                    ))
                    if not any(handled_error):
                        raise self._create_invalid_type(
                            '{{field_name}}',
                            val, type(val), type_restriction)
                    return
                    {%- else %}
                    raise self._create_invalid_type(
                        '{{field_name}}',
                        val, type(val), type_restriction)
                    {%- endif %}
            # Transactional set:
            try:
                self._data.{{field_name}} = val
                {%- if on_sets %}
                {%- for on_func_name in on_sets %}
                self.{{on_func_name}}(_old_value, val)
                {%- endfor %}
                {%- endif %}
                {%- if history %}
                if not self._flags:
                    del _old_value
                    return
                self._record_change('{{field_name}}', _old_value, val)
                {%- endif %}
            except Exception:
                self._data.{{field_name}} = _old_value
                raise
            del _old_value

    return _set_{{field_name}}
{% endmacro %}
