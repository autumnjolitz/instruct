from collections import Mapping, namedtuple, UserDict
from typing import Union
import time
from enum import IntEnum
import textwrap

from .about import __version__
__version__  # Silence unused import warning.

NoneType = type(None)
DEFAULT_GET_BLOCK = 'return self._{key}'
DEFAULT_SET_BLOCK = 'self._{key} = val'

GETTER = '''
def make_getter(type_def):
    def {key}(self) -> type_def:
        %%GET_VARIABLE%%
    return {key}
'''

SETTER = '''
def make_setter(type_def, fast, derived=None):
    type_restriction = type_def
    if hasattr(type_def, '__origin__') and type_def.__origin__ is Union:
        type_restriction = type_def._subs_tree()
        if type_restriction is Union:
            type_restriction = (object,)
        elif isinstance(type_restriction, tuple):
            # Trim off the preceding Union datatype
            type_restriction = type_restriction[1:]
    if isinstance(type_restriction, type):
        type_restriction = (type_restriction,)

    assert isinstance(type_restriction, tuple) and all(
        isinstance(cls, type) for cls in type_restriction), \\
        'Not all types {{!r}} are cls'.format(type_restriction)
    if not fast:
        def {key}(self, val: type_def) -> NoneType:
            if not isinstance(val, type_restriction):
                if isinstance(val, dict) and derived is not None:
                    val = derived(**val)
                if not isinstance(val, type_restriction):
                    raise TypeError('{{!r}} must be a {{}}'.format(val, type_restriction))
            %%SET_VARIABLE%%
    else:
        def {key}(self, val: type_def) -> NoneType:
            %%SET_VARIABLE%%
    return {key}
'''.strip()

HISTORY_SETTER_BLOCK = '''
if not self.flags:
    %%SET_VARIABLE%%
    return
old_value = self.{key}
%%SET_VARIABLE%%
self._record_change('{key}', old_value, val)
'''.strip()


def make_redirector(variables):
    def __getattr__(self, key):
        if key in variables:
            key = f'_{key}'
        return super(self.__class__, self).__getattr__(key)

    def __setattr__(self, key, value):
        if key in variables:
            key = f'_{key}'
        return super(self.__class__, self).__setattr__(key, value)

    return __getattr__, __setattr__


class AttrsDict(UserDict):
    def __getattr__(self, key):
        try:
            return self.data[key]
        except KeyError:
            self.data[key] = None
            return None


class ReadOnly:
    def __init__(self, value):
        self.value = value

    def __get__(self, obj, objtype=None):
        return self.value

    def __set__(self, obj, val):
        raise NotImplementedError

eq_template = '''
def __eq__(self, other):
    \'\'\'
    Autogenerated code: This represents a giant if-else chain to fast field comparison.
    \'\'\'
    try:
        return {}
    except AttributeError:
        return False
'''

clear_template = '''
def clear(self, fields=None):
    \'\'\'
    Autogenerated code: This attempts to set all the slot fields to None
    \'\'\'
    if not fields:
        if fields is None:
            fields = self._columns
        else:
            fields = ()
    val = None
    {}
    super(self.__class__, self).clear(fields)
'''.strip()

clear_block = '''
if '{key}' in fields:
        {set_block}
'''.strip()


def make_fast_clear(fields, set_block=DEFAULT_SET_BLOCK):
    lines = []
    for field in fields:
        lines.append(clear_block.format(
            key=field, set_block=set_block.format(key=field)))
    code = clear_template.format('\n'.join('    {}'.format(line) for line in lines).lstrip())
    return code


def make_fast_eq(fields):
    fields = ['self.{0} == other.{0}'.format(key) for key in fields]
    return eq_template.format(' and '.join(fields))


class Atomic(type):
    __slots__ = ()
    REGISTRY = ReadOnly(set())
    MIXINS = ReadOnly({})

    @classmethod
    def register_mixin(cls, name, klass):
        cls.MIXINS[name] = klass

    def __new__(klass, class_name, bases, attrs, fast=None, **mixins):
        if fast is None:
            fast = not __debug__
        if '__slots__' not in attrs:
            raise TypeError(
                f'You must define __slots__ for {class_name} to constrain the typespace')
        if not isinstance(attrs['__slots__'], Mapping):
            if isinstance(attrs['__slots__'], tuple):
                return super().__new__(klass, class_name, bases, attrs)
            raise TypeError(
                f'The __slots__ definition for {class_name} must be a mapping or empty tuple!')

        if 'fast' in attrs:
            fast = attrs.pop('fast')
        columns = {}
        derived_classes = {}
        for key, value in attrs['__slots__'].items():
            if isinstance(value, dict):
                value = type('{}'.format(key.capitalize()), bases, {'__slots__': value})
                derived_classes[key] = value
                attrs['__slots__'][key] = value
            columns[key] = value

        for mixin_name in mixins:
            if mixins[mixin_name]:
                mixin_cls = klass.MIXINS[mixin_name]
                if isinstance(mixins[mixin_name], type):
                    mixin_cls = mixins[mixin_name]
                bases = (mixin_cls,) + bases
        # Setup wrappers are nested
        # pieces of code that effectively surround a part that sets
        #    self._{key} -> value
        # They must be reindented properly
        setter_wrapper = []
        for cls in bases:
            if hasattr(cls, '__slots__') and isinstance(cls.__slots__, dict):
                for key, value in cls.__slots__.items():
                    columns[key] = value
            if hasattr(cls, 'setter_wrapper'):
                setter_wrapper.append(cls.setter_wrapper)

        setter_template = SETTER
        getter_template = GETTER
        for wrapper in setter_wrapper:
            index = block_index = setter_template.index('%%SET_VARIABLE%%')
            while setter_template:
                if setter_template[index-1] == '\n':
                    break
                index -= 1
            indent = setter_template[index:block_index]

            block_endex = block_index + len('%%SET_VARIABLE%%')
            setter_template = '{}{}{}'.format(
                setter_template[:block_index],
                textwrap.indent(wrapper, indent).lstrip(),
                setter_template[block_endex:])
        setter_template = setter_template.replace('%%SET_VARIABLE%%', DEFAULT_SET_BLOCK)
        getter_template = getter_template.replace('%%GET_VARIABLE%%', DEFAULT_GET_BLOCK)

        attrs['_columns'] = ReadOnly(columns)
        conf = AttrsDict(**mixins)
        conf['fast'] = fast
        attrs['_configuration'] = ReadOnly(conf)
        ns_globals = {'Union': Union, 'NoneType': type(None), 'Flags': Flags}
        for key, value in attrs['__slots__'].items():
            if value in klass.REGISTRY:
                derived_classes[key] = value
            if key[0] == '_':
                continue
            attrs['__slots__'][f'_{key}'] = value
            del attrs['__slots__'][key]
            ns = {}
            getter_code = getter_template.format(key=key)
            setter_code = setter_template.format(key=key)
            exec(getter_code, ns_globals, ns)
            exec(setter_code, ns_globals, ns)
            attrs[key] = property(
                ns['make_getter'](value),
                ns['make_setter'](value, fast, derived_classes.get(key)))
        exec(make_fast_eq(tuple(columns)), ns_globals, ns_globals)
        exec(make_fast_clear(tuple(columns)), ns_globals, ns_globals)
        attrs['__eq__'] = ns_globals['__eq__']
        attrs['clear'] = ns_globals['clear']

        new_cls = super().__new__(klass, class_name, bases, attrs)
        klass.REGISTRY.add(new_cls)
        return new_cls

Delta = namedtuple('Delta', ['state', 'old', 'new', 'index'])
LoggedDelta = namedtuple('LoggedDelta', ['timestamp', 'key', 'delta'])


class Undefined(object):
    def __repr__(self):
        return 'Undefined'

UNDEFINED = Undefined()


class History(object):
    __slots__ = ()
    setter_wrapper = ReadOnly(HISTORY_SETTER_BLOCK)

    def clear(self, fields):
        self._changed_index = 0
        t_s = time.time()
        self._changes = {
            key: [Delta('default', UNDEFINED, getattr(self, key), 0)] for key in self._columns
        }
        self._changed_keys = [(key, t_s) for key in self._columns]
        self._changed_index += len(self._changed_keys)
        super().clear(fields)

    def __setattr__(self, key, value):
        super().__setattr__(key, value)
        if self.flags & Flags.IN_CONSTRUCTOR and key in self._columns:
            self._changed_index += 1

    def _record_change(self, key, old_value, new_value):
        if old_value == new_value:
            return
        if self.flags & Flags.DISABLE_HISTORY:
            return
        msg = 'update'
        if self.flags & 2 == 2:
            msg = 'initialized'
        else:
            _, old_val_prior, _, index = self._changes[key][-1]
            if new_value == old_val_prior:
                self._changes[key].pop()
                del self._changed_keys[index]
                return

        index = len(self._changed_keys)
        self._changed_keys.append((key, time.time()))
        self._changes[key].append(Delta(msg, old_value, new_value, index))

    @property
    def is_dirty(self):
        return len(self._changed_keys[self._changed_index:]) > 0

    def reset_changes(self, *keys):
        if not keys:
            keys = self._columns.keys()
        self.flags |= Flags.DISABLE_HISTORY
        for key in keys:
            first_changes = self._changes[key][:2]
            self._changes[key][:2] = first_changes

            val = first_changes[0].new  # Constructor default, defaults to None
            if len(first_changes) == 2:
                assert first_changes[1].state == 'initialized'
                val = first_changes[1].new  # Use the initialized default
            setattr(self, key, val)
        self.flags &= (self.flags ^ Flags.DISABLE_HISTORY)

    def list_changes(self):
        key_counter = {}
        for key, delta_time in self._changed_keys:
            if key not in key_counter:
                key_counter[key] = 0
            index = key_counter[key]
            delta = self._changes[key][index]

            yield LoggedDelta(delta_time, key, delta)
            key_counter[key] += 1

Atomic.register_mixin('history', History)


class Flags(IntEnum):
    IN_CONSTRUCTOR = 1
    DEFAULTS_SET = 2
    INITIALIZED = 4
    DISABLE_HISTORY = 8


class ClassDefault:
    def __init__(self, default):
        self.default = default

    def __get__(self, obj, obj_type=None):
        if obj and not hasattr(obj, '_flags'):
            obj._flags = self.default
        return getattr(obj, '_flags', self.default)

    def __set__(self, obj, val):
        obj._flags = val


class Base(metaclass=Atomic):
    __slots__ = ('_changes', '_changed_keys', '_flags', '_changed_index',)
    flags = ClassDefault(0)

    def __init__(self, **kwargs):
        self.flags |= Flags.IN_CONSTRUCTOR
        fields = []
        for key in self._columns:
            if getattr(self, key, UNDEFINED) is UNDEFINED:
                fields.append(key)
        self.clear(fields)
        self.flags |= Flags.DEFAULTS_SET
        for key in self._columns.keys() & kwargs.keys():
            value = kwargs[key]
            setattr(self, key, value)

        if kwargs.keys() - self._columns.keys():
            fields = ', '.join(kwargs.keys() - self._columns.keys())
            raise ValueError(f'Unrecognized fields {fields}')
        self.flags = Flags.INITIALIZED

    def clear(self, fields):
        pass


